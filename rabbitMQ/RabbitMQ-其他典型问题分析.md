# 消息堆积

在长时间内，当消息生产的速度远远大于消息消费的速度，就会造成消息堆积。

消息堆积的影响：

- 可能导致新消息无法进入队列
- 可能导致旧消息无法丢失
- 消息等待消费的时间过长，超出了业务容忍范围

产生堆积的情况：

- 生产者突然大量发布消息
- 消费者消费失败
- 消费者出现性能瓶颈

解决思路：

- 排查消费者消费性能瓶颈
- 增加消费者多线程处理
- 部署增加多个消费者

如果消息已经堆积，又该如何解决呢？一个典型的思路，如果业务允许，想办法把已经堆积的消息转移到一个新的队列，使得原队列能继续对外服务，增加服务器来消费这个新的队列即可。

# 有序消费消息

当RabbitMQ存在多个消费者Consumer时，显然的，多个Consumer是竞争关系，此时就会出现MQ消息乱序的问题。

如果所示，理情况下，我们想让消息与对应的消费者一一顺序对应，但实际情况的顺序很可能是不一致的。

![1589077248507](C:/Users/wyf/AppData/Roaming/Typora/typora-user-images/1589077248507.png)

此外，还有另一种情况，消费者只有一个，但是利用了多线程消费消息，也会造成顺序不一致的情况



![1589077412058](C:/Users/wyf/AppData/Roaming/Typora/typora-user-images/1589077412058.png)



针对以上两种情况，考虑有以下解决方案：

- 针对多个消费者消费

  考虑增加队列，采用一定的路由算法，使得消息与对应的队列绑定，队列又与对应的消费者绑定。比如如下所示，利用ID对队列个数取余，就能让相同ID的消息发送到用一个队列，一个队列由一个消费者消费，不存在消费者竞争的情况。

  ![1589077640317](C:/Users/wyf/AppData/Roaming/Typora/typora-user-images/1589077640317.png)

  

- 针对单个消费者，多线程消费

  与多消费的解决思路类似，可以利用内存队列，比如Java的Queue，将消息进行分组，然后每一个分组后的消息交由一个线程处理

  ![1589077916125](C:/Users/wyf/AppData/Roaming/Typora/typora-user-images/1589077916125.png)

总之，整体思路就是，只要**保证入队有序就行，出队以后的顺序交给消费者自己去保证**，没有固定套路。

# 重复消费

其实无论是那种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。那造成重复消费的原因?，就是因为网络传输等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。
  如何解决?这个问题针对业务场景来答分以下几点
  (1)比如，你拿到这个消息做数据库的insert操作。很容易就想到，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。
  (2)再比如，你拿到这个消息做redis的set的操作，都不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。
  (3)如果上面两种情况还不行，准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将<id,message>以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。