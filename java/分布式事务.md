分布式事务

# 1.2PC/XA

XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），主要定义全局事务管理器和局部资源管理器之间的接口。



# 2.解决方案

## 0.可靠消息最终一致性方案

1. A系统先发送一个prepared消息到mq，如果这个prepared消息发送失败那么就直接取消操作别执行了，后续操作都不再执行

2. 如果这个消息发送成功过了，那么接着执行A系统的本地事务，如果执行失败就告诉mq回滚消息，后续操作都不再执行

3. 如果A系统本地事务执行成功，就告诉mq发送确认消息

4. 那如果A系统迟迟不发送确认消息呢？

   此时mq会自动定时轮询所有prepared消息，然后调用A系统事先提供的接口，通过这个接口反查A系统的上次本地事务是否执行成功

   如果成功，就发送确认消息给mq；失败则告诉mq回滚消息（后续操作都不再执行）

5. 此时B系统会接收到确认消息，然后执行本地的事务，如果本地事务执行成功则事务正常完成

6. 如果系统B的本地事务执行失败了咋办？

   基于mq重试咯，mq会自动不断重试直到成功，如果实在是不行，可以发送报警由人工来手工回滚和补偿

## 1.TCC（Try-Confirm-Cancel）两阶段补偿型方案

- Try 阶段：尝试执行，完成所有业务检查（一致性），预留必需业务资源（准隔离性）。
- Confirm 阶段：确认真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。
- Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源，Cancel 操作满足幂等性。Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。

![TCC](D:\Program Files\笔记\image\TCC.JPG)

服务器 A 的事务如果执行顺利，那么事务 A 就先行提交，如果事务 B 也执行 顺利，则事务 B 也提交，整个事务就算完成。但是如果事务 B 执行失败，事务 B 本身回滚，这时 事务 A 已经被提交，所以需要执行一个补偿操作，将已经提交的事务 A 执行的操作作反操作，恢 复到未执行前事务 A 的状态

**不同于2PC在最后阶段释放锁资源，TCC在Try阶段之后就释放了**

**开源框架实现：Atomikos，tcc-transaction,spring-cloud-test-tcc**

## 2.本地消息表

利用消息队列，通过将一系列同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务 中的同步阻塞操作的影响。

基本思路就是：将远程分布式事务拆分成一系列的本地事务

消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。

消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。

生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。

## 3.最大努力通知型

这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步 确保型操作不同的一点是, **在消息由MQ Server 投递到消费者之后, 允许在达到最大重试次数之后 正常结束事务。**

## 4.LCN

TX-LCN由两大模块组成, TxClient、TxManager，TxClient作为模块的依赖框架，提供TX-LCN的标准支持，TxManager作为分布式事务的控制方。

锁定事务单元（lock）
确认事务模块状态(confirm)
通知事务(notify)

![LCN](D:\Program Files\笔记\image\LCN.png)

### 核心步骤

- 创建事务组
  是指在事务发起方开始执行业务代码之前先调用TxManager创建事务组对象，然后拿到事务标示GroupId的过程。
- 加入事务组
  添加事务组是指参与方在执行完业务方法以后，将该模块的事务信息通知给TxManager的操作。
- 通知事务组
  是指在发起方执行完业务代码以后，将发起方执行结果状态通知给TxManager,TxManager将根据事务最终状态和事务组的信息来通知相应的参与模块提交或回滚事务，并返回结果给事务发起方。

# 3.分布式ID解决方案

## 1.**UUID**

UUID是通用唯一识别码 (Universally Unique Identifier)，在其他语言中也叫GUID，可以生成一个长度32位的全局唯一识别码。

```
String uuid = UUID.randomUUID().toString()
```

但缺点是**无代表意义，且是无序的，保存数据库会导致一些中间节点产生分裂**，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能。

## 2.**数据库自增主键**

假设名为table的表有如下结构：

id feild

35 a

每一次生成ID的时候，访问数据库，执行下面的语句：

```sql
begin;

REPLACE INTO table ( feild ) VALUES ( 'a' );

SELECT LAST_INSERT_ID();

commit;
```

REPLACE INTO 的含义是插入一条记录，如果表中唯一索引的值遇到冲突，则替换老数据。

这样一来，每次都可以得到一个递增的ID。

为了提高性能，在分布式系统中可以用DB proxy请求不同的分库，每个分库设置不同的初始值，步长和分库数量相等。

缺点:**id的生成严重依赖DB**

## 3.SnowFlake

![snowflake](D:\Program Files\笔记\image\snowflake.JPG)

SnowFlake所生成的ID一共分成四部分：

**1.第一位**

占用1bit，其值始终是0，没有实际作用。

**2.时间戳**

占用41bit，精确到毫秒，总共可以容纳约69 年的时间。

**3.工作机器id**

占用10bit，其中高位5bit是数据中心ID（datacenterId），低位5bit是工作节点ID（workerId），做多可以容纳1024个节点。

**4.序列号**

占用12bit，这个值在同一毫秒同一节点上从0开始不断累加，最多可以累加到4095。

SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？只需要做一个简单的乘法：

**同一毫秒的ID数量 = 1024 X 4096 = 4194304**

**优点：**

1.生成ID时不依赖于DB，完全在内存生成，高性能高可用。

2.ID呈趋势递增，后续插入索引树的时候性能较好。

**缺点：**

依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。

