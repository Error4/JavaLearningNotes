# 1.用户管理

Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须先申请一个账号，然后以这个账号的身份进入系统。每个用户账号都拥有一个唯一的用户名和各自的口令。

用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。

## 1.1 用户账号管理

用户账号的管理工作主要涉及到用户账号的添加、修改和删除。

### 添加账号(useradd)

```
useradd 选项 用户名
```

参数说明：

- 选项 :

- - -c comment 指定一段注释性描述。
  - -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
  - -g 用户组 指定用户所属的用户组。
  - -G 用户组，用户组 指定用户所属的附加组。
  - -m　使用者目录如不存在则自动建立。
  - -s Shell文件 指定用户的登录Shell。
  - -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。

- 用户名 :

- - 指定新账号的登录名。

```
# 此命令创建了一个用户wyf，其中-m选项用来为登录名wyf产生一个主目录 
useradd -m wyf
```

### 删除用户(userdel)

删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。

```
userdel 选项 用户名
```

常用的选项是 **-r**，它的作用是把用户的主目录一起删除。

```
userdel -r wyf
```

此命令删除用户wyf在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。

### 修改用户(usermod)

修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组等。

修改已有用户的信息使用usermod命令，其格式如下：

```
usermod 选项 用户名
```

常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，意义与`useradd`命令中的选项一致，可以为用户指定新的资源值。

例如：

```
# usermod -s /bin/ksh -d /home/z –g developer wyf
```

此命令将用户wyf的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。

### 切换用户

```
su username 【username是目标用户名】
```

从普通用户切换到root用户，还可以使用命令：sudo su

在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令

在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：`su - root`

## 1.2 用户口令的管理

用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。

格式如下:

```
passwd 选项 用户名
```

| 选项 | 含义                                 |
| ---- | ------------------------------------ |
| -l   | 锁定口令，即禁用账号，使其不能登录。 |
| -u   | 口令解锁。                           |
| -d   | 使账号无口令。                       |
| -f   | 强迫用户下次登录时修改口令。         |

如果默认用户名，则修改当前用户的口令。

例如，假设当前用户是wyf，则下面的命令修改该用户自己的口令：

```
$ passwd
Old password:******
New password:*******
Re-enter new password:*******
```

如果是超级用户，可以用下列形式指定任何用户的口令：

```
# passwd wyf 
password:*******
Re-enter new password:*******
```

## 1.3 用户组管理

每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。。用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。

### 添加用户组(groupadd)

```
groupadd 选项 用户组
```

可以使用的选项有：

- -g  GID 指定新用户组的组标识号（GID）。
- -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。

实例1：

```
# groupadd group1
```

此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。

实例2：

```
# groupadd -g 101 group2
```

此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。

### 删除用户组(groupdel)

```
groupdel 用户组
```

例如：

```
# groupdel group1
```

此命令从系统中删除组group1。

### 修改用户组(groupmod)

```
groupmod 选项 用户组
```

常用的选项有：

- -g GID 为用户组指定新的组标识号。
- -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
- -n新用户组 将用户组的名字改为新名字

例如：

```
groupmod -g 102 group2
```

此命令将组group2的组标识号修改为102。

```
groupmod –g 10000 -n group3 group2
```

将组group2的标识号改为10000，组名修改为group3。

### 切换组

如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。

用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：

```
$ newgrp root
```

这条命令将当前用户切换到root用户组

# 2.文件和目录管理

## 2.1 切换目录(cd)

cd 命令，是 Change Directory 的缩写，用来切换工作目录。

基本格式如下：

```
# cd 选项 [相对路径或绝对路径]
```

| 选项    | 含义                       |
| ------- | -------------------------- |
| ~       | 代表当前登录用户的主目录   |
| ~用户名 | 表示切换至指定用户的主目录 |
| -       | 代表上次所在目录           |
| .       | 代表当前目录               |
| ..      | 代表上级目录               |

## 2.2 显示当前路径(pwd)

pwd 命令，是 Print Working Directory （打印工作目录）的缩写，功能是显示用户当前所处的工作目录。基本格式：

```
# pwd
```

## 2.3 查看目录下文件(ls)

ls 命令，list 的缩写，主要功能是显示当前目录下的内容。基本格式：

```
# ls [选项] 目录名称
```

| 选项                                      | 含义                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| -a                                        | 显示全部的文件，包括隐藏文件（开头为 . 的文件）也一起罗列出来，这是最常用的选项之一。 |
| -A                                        | 显示全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录。  |
| -d                                        | 仅列出目录本身，而不是列出目录内的文件数据。                 |
| -f                                        | ls 默认会以文件名排序，使用 -f 选项会直接列出结果，而不进行排序。 |
| -F                                        | 在文件或目录名后加上文件类型的指示符号，例如，* 代表可运行文件，/ 代表目录，= 代表 [socket](http://c.biancheng.net/socket/) 文件，\| 代表 FIFO 文件。 |
| -h                                        | 以人们易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等。  |
| -i                                        | 显示 inode 节点信息。                                        |
| -l                                        | 使用长格式列出文件和目录信息。                               |
| -n                                        | 以 UID 和 GID 分别代替文件用户名和群组名显示出来。           |
| -r                                        | 将排序结果反向输出，比如，若原本文件名由小到大，反向则为由大到小。 |
| -R                                        | 连同子目录内容一起列出来，等於将该目录下的所有文件都显示出来。 |
| -S                                        | 以文件容量大小排序，而不是以文件名排序。                     |
| -t                                        | 以时间排序，而不是以文件名排序。                             |
| --color=never --color=always --color=auto | never 表示不依据文件特性给予颜色显示。 always 表示显示颜色，ls 默认采用这种方式。 auto 表示让系统自行依据配置来判断是否给予颜色。 |
| --full-time                               | 以完整时间模式 （包含年、月、日、时、分）输出                |
| --time={atime,ctime}                      | 输出 access 时间或改变权限属性时间（ctime），而不是内容变更时间。 |

## 2.4 创建/删除 目录(mkdir/rmdir)

mkdir 命令，是 make directories 的缩写，用于创建新目录

```
# mkdir [-mp] 目录名
```

- -m 选项用于手动配置所创建目录的权限，而不再使用默认权限。
- -p 选项递归创建所有目录，以创建 /home/test/demo 为例，在默认情况下，你需要一层一层的创建各个目录，而使用 -p 选项，则系统会自动帮你创建 /home、/home/test 以及 /home/test/demo。

rmdir（remove empty directories 的缩写）命令用于删除空目录

```
# rmdir [-p] 目录名
```

-p 选项用于递归删除空目录。

## 2.5 创建文件及修改文件时间戳(touch)

touch 命令可以用来创建文件（当**指定操作文件不存在**时，该命令会在当前位置**建立一个空文件**），此命令更重要的功能是修改文件的时间参数（但当**文件存在**时，会**修改此文件的时间参数**）。

linux系统中，每个文件主要拥有 3 个时间参数：

- 访问时间（Access Time，简称 atime）：只要文件的内容被读取，访问时间就会更新。例如，使用 cat 命令可以查看文件的内容，此时文件的访问时间就会发生改变。
- 数据修改时间（Modify Time，简称 mtime）：当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变。
- 状态修改时间（Change Time，简称 ctime）：当文件的状态发生变化，就会相应改变这个时间。比如说，如果文件的权限或者属性发生改变，此时间就会相应改变。

```
touch [选项] 文件名
```

| 选项 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | 只修改文件的访问时间                                         |
| -c   | 仅修改文件的时间参数（3 个时间参数都改变），如果文件不存在，则不建立新文件 |
| -d   | 后面可以跟欲修订的日期，即把文件的 atime 和 mtime 时间改为指定的时间。 |
| -m   | 只修改文件的数据修改时间                                     |
| -t   | 命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 `YYMMDDhhmm |

## 2.6 建立链接文件(ln)

我们知道文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。

![](https://s1.ax1x.com/2020/09/06/wmsrkj.jpg)

为解决文件的共享使用，Linux 系统引入了两种链接：硬链接 (hard link) 与软链接

若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：

- 文件有相同的 inode 及 data block；
- 只能对已存在的文件进行创建；
- 不能交叉文件系统进行硬链接的创建；
- 不能对目录进行创建，只可对文件创建；
- 删除一个硬链接文件并不影响其他有相同 inode 号的文件。

软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块。因此软链接的创建与使用没有类似硬链接的诸多限制：

- 软链接有自己的文件属性及权限等；
- 可对不存在的文件或目录创建软链接；
- 软链接可交叉文件系统；
- 软链接可对文件或目录创建；
- 创建软链接时，链接计数 i_nlink 不会增加；
- 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。

![](https://s1.ax1x.com/2020/09/06/wmsB7Q.jpg)

ln 命令用于给文件创建链接，基本格式如下：

```
# ln [选项] 源文件 目标文件
```

选项：

- s：建立软链接文件。如果不加 "-s" 选项，则建立硬链接文件；

- f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件；

## 2.7 复制文件和目录(cp)

cp 命令，主要用来复制文件和目录，同时借助某些选项，还可以实现复制整个目录。基本格式如下：

```
# cp [选项] 源文件 目标文件
```

| 选项 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | 相当于 -d、-p、-r 选项的集合，这几个选项我们一一介绍；       |
| -d   | 如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接； |
| -i   | 询问，如果目标文件已经存在，则会询问是否覆盖；               |
| -l   | 把目标文件建立为源文件的硬链接文件，而不是复制源文件；       |
| -s   | 把目标文件建立为源文件的软链接文件，而不是复制源文件；       |
| -p   | 复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）； |
| -r   | 递归复制，用于复制目录；                                     |
| -u   | 若目标文件比源文件有差异，则使用该选项可以更新目标文件，此选项可用于对文件的升级和备用。 |

## 2.8 删除文件或目录(rm)

rm 可以永久性地删除文件系统中指定的文件或目录。基本格式如下：

```
# rm[选项] 文件或目录
```

| 选项 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| -f   | 强制删除（force），和 -i 选项相反，使用 -f，系统将不再询问，而是直接删除目标文件或目录。 |
| -i   | 和 -f 正好相反，在删除文件或目录之前，系统会给出提示信息，使用 -i 可以有效防止不小心删除有用的文件或目录。 |
| -r   | 递归删除，主要用于删除目录，可删除指定目录及包含的所有内容，包括所有的子目录和文件。 |

## 2.9 移动文件或改名(mv)

mv 命令（move 的缩写），既可以在不同的目录之间移动文件或目录，也可以对文件和目录进行重命名。基本格式如下：

```
# mv 【选项】 源文件 目标文件
```

| 选项 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| -f   | 强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖       |
| -i   | 交互移动，如果目标文件已经存在，则询问用户是否覆盖（默认选项） |
| -n   | 如果目标文件已经存在，则不会覆盖移动，而且不询问用户         |
| -v   | 显示文件或目录的移动过程                                     |
| -u   | 若目标文件已经存在，但两者相比，源文件更新，则会对目标文件进行升级 |

# 3.打包（归档）和压缩

归档，也称为打包，指的是一个文件或目录的集合，而这个集合被存储在一个文件中。归档文件没有经过压缩，因此，它占用的空间是其中所有文件和目录的总和。

压缩是指利用算法将文件进行处理，已达到保留最大文件信息，而让文件体积变小的目的。其基本原理为，通过查找文件内的重复字节，建立一个相同字节的词典文件，并用一个代码表示。

Linux 下，常用归档命令有 2 个，分别是 tar 和 dd（相对而言，tar 的使用更为广泛）；常用的压缩命令有很多，比如 gzip、zip、bzip2 等。

## 3.1 tar打包命令

命令可以将许多文件一起保存到一个单独的磁带或磁盘中进行归档，反之，还可以从归档文件中还原所需文件。基本格式为：

```
#tar [选项] 源文件或目录
```

| 选项     | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| -c       | 将多个文件或目录进行打包。                                   |
| -A       | 追加 tar 文件到归档文件。                                    |
| -f 包名  | 指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名； |
| -v       | 显示打包/解打包文件过程；                                    |
| -x       | 对 tar 包做解打包操作。                                      |
| -t       | 只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。   |
| - C 目录 | 指定解打包位置。                                             |

例如

```
# tar -cvf A.cfg.tar A.cfg
```

把A.cfg打包为 A.cfg.tar文件，记住打包时需要指定打包之后的文件名，而且要用 ".tar" 作为扩展名。

```
tar -xvf A.cfg. tar
```

包中的文件解压到当前目录下

此外，也可以将打包和压缩置于一块完成，利用-z或-j的选项即可

- -z：压缩和解压缩 ".tar.gz" 格式；
- -j：压缩和解压缩 ".tar.bz2"格式。

```
# tar -zcvf tmp.tar.gz /tmp/
```

把/temp/目录直接打包压缩为".tar.gz"格式

## 3.2 压缩和解压缩.zip格式

- 压缩

  基本格式如下，需要注意，zip 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用。

  ```
  #zip [选项] 压缩包名 源文件或源目录列表
  ```

  | 选项      | 含义                                                         |
  | --------- | ------------------------------------------------------------ |
  | -r        | 递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。   |
  | -m        | 将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。   |
  | -v        | 显示详细的压缩过程信息。                                     |
  | -q        | 在压缩的时候不显示命令的执行过程。                           |
  | -压缩级别 | 压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。 |
  | -u        | 更新压缩文件，即往压缩文件中添加新文件。                     |

- 解压缩

  基本格式如下：

  ```
  # unzip [选项] 压缩包名
  ```

  | 选项        | 含义                                                         |
  | ----------- | ------------------------------------------------------------ |
  | -d 目录名   | 将压缩文件解压到指定目录下。                                 |
  | -n          | 解压时并不覆盖已经存在的文件。                               |
  | -o          | 解压时覆盖已经存在的文件，并且无需用户确认。                 |
  | -v          | 查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。 |
  | -t          | 测试压缩文件有无损坏，但并不解压。                           |
  | -x 文件列表 | 解压文件，但不包含文件列表中指定的文件。                     |

## 3.3 压缩和解压缩.gz格式

- 压缩

  与zip命令不同，gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。

  ```
  # gzip [选项] 源文件
  ```

  | 选项  | 含义                                                         |
  | ----- | ------------------------------------------------------------ |
  | -c    | 将压缩数据输出到标准输出中，并保留源文件。                   |
  | -d    | 对压缩文件进行解压缩。                                       |
  | -r    | 递归压缩指定目录下以及子目录下的所有文件。                   |
  | -v    | 对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。       |
  | -l    | 对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称。 |
  | -数字 | 用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6。 |

  例如：

  ```
  # gzip install.log
  ```

- 解压缩

  除了上面说到的-d选项外，还可以使用gunzip进行解压缩

  ```
  gunzip [选项] 文件
  ```

  | 选项 | 含义                                               |
  | ---- | -------------------------------------------------- |
  | -r   | 递归处理，解压缩指定目录下以及子目录下的所有文件。 |
  | -c   | 把解压缩后的文件输出到标准输出设备。               |
  | -f   | 强制解压缩文件，不理会文件是否已存在等情况。       |
  | -l   | 列出压缩文件内容。                                 |
  | -v   | 显示命令执行过程。                                 |
  | -t   | 测试压缩文件是否正常，但不对其做解压缩操作。       |

## 3.4 压缩和解压缩.bz2格式

bzip2 命令同 gzip 命令类似，当执行压缩任务完成后，会生成一个以“.bz2”为后缀的压缩包。从理论上来讲，".bz2"格式的算法更先进、压缩比更好；而 ".gz"格式相对来讲的时间更快。

- 压缩

  ```
  # bzip2 [选项] 源文件
  ```

  | 选项  | 含义                                                         |
  | ----- | ------------------------------------------------------------ |
  | -d    | 执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件。 |
  | -k    | bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项。 |
  | -f    | bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件。 |
  | -t    | 测试压缩包文件的完整性。                                     |
  | -v    | 压缩或解压缩文件时，显示详细信息。                           |
  | -数字 | 这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高 |

- 解压缩

  ```
  bunzip2 [选项] 源文件
  ```

  | 选项 | 含义                                                         |
  | ---- | ------------------------------------------------------------ |
  | -k   | 解压缩后，默认会删除原来的压缩文件。若要保留压缩文件，需使用此参数。 |
  | -f   | 解压缩时，若输出的文件与现有文件同名时，默认不会覆盖现有的文件。若要覆盖，可使用此选项。 |
  | -v   | 显示命令执行过程。                                           |
  | -L   | 列出压缩文件内容。                                           |

# 4.vim编辑器

所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。但是目前我们使用比较多的是 vim 编辑器。

基本上 vi/vim 共分为三种模式，分别是**命令模式（Command mode）**，**输入模式（Insert mode）**和**底线命令模式（Last line mode）**。

## 4.1 命令模式

用户刚刚启动 vi/vim，便进入了命令模式。

此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。

以下是常用的几个命令：

- **i** 切换到输入模式，以输入字符。
- **x** 删除当前光标所在处的字符。
- **:** 切换到底线命令模式，以在最底一行输入命令。

## 4.2 输入模式

在命令模式下按下i就进入了输入模式。

在输入模式中，可以使用以下按键：

- **字符按键以及Shift组合**，输入字符
- **ENTER**，回车键，换行
- **BACK SPACE**，退格键，删除光标前一个字符
- **DEL**，删除键，删除光标后一个字符
- **方向键**，在文本中移动光标
- **HOME**/**END**，移动光标到行首/行尾
- **Page Up**/**Page Down**，上/下翻页
- **Insert**，切换光标为输入/替换模式，光标将变成竖线/下划线
- **ESC**，退出输入模式，切换到命令模式

## 4.3 底线命令模式

在命令模式下按下:（英文冒号）就进入了底线命令模式。基本的命令有（已经省略了冒号）：

- q 退出程序
- w 保存文件

按ESC键可随时退出底线命令模式。

简单的说，我们可以将这三个模式想成底下的图标来表示：

![](https://www.runoob.com/wp-content/uploads/2014/07/vim-vi-workmodel.png)



> Vim 按键说明

**第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等**

| 移动光标的方法     |                                                              |
| :----------------- | ------------------------------------------------------------ |
| h 或 向左箭头键(←) | 光标向左移动一个字符                                         |
| j 或 向下箭头键(↓) | 光标向下移动一个字符                                         |
| k 或 向上箭头键(↑) | 光标向上移动一个字符                                         |
| l 或 向右箭头键(→) | 光标向右移动一个字符                                         |
| [Ctrl] + [f]       | 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)          |
| [Ctrl] + [b]       | 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)           |
| [Ctrl] + [d]       | 屏幕『向下』移动半页                                         |
| [Ctrl] + [u]       | 屏幕『向上』移动半页                                         |
| +                  | 光标移动到非空格符的下一行                                   |
| -                  | 光标移动到非空格符的上一行                                   |
| n< space>          | 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。 |
| 0 或功能键[Home]   | 这是数字『 0 』：移动到这一行的最前面字符处 (常用)           |
| $ 或功能键[End]    | 移动到这一行的最后面字符处(常用)                             |
| H                  | 光标移动到这个屏幕的最上方那一行的第一个字符                 |
| M                  | 光标移动到这个屏幕的中央那一行的第一个字符                   |
| L                  | 光标移动到这个屏幕的最下方那一行的第一个字符                 |
| G                  | 移动到这个档案的最后一行(常用)                               |
| nG                 | n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) |
| gg                 | 移动到这个档案的第一行，相当于 1G 啊！(常用)                 |
| n< Enter>          | n 为数字。光标向下移动 n 行(常用)                            |

| 搜索替换 |                                                              |
| :------- | ------------------------------------------------------------ |
| /word    | 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用) |
| ?word    | 向光标之上寻找一个字符串名称为 word 的字符串。               |
| n        | 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ |
| N        | 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 |

| 删除、复制与粘贴 |                                                              |
| :--------------- | ------------------------------------------------------------ |
| x, X             | 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) |
| nx               | n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 |
| dd               | 删除游标所在的那一整行(常用)                                 |
| ndd              | n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) |
| d1G              | 删除光标所在到第一行的所有数据                               |
| dG               | 删除光标所在到最后一行的所有数据                             |
| d$               | 删除游标所在处，到该行的最后一个字符                         |
| d0               | 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符      |
| yy               | 复制游标所在的那一行(常用)                                   |
| nyy              | n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) |
| y1G              | 复制游标所在行到第一行的所有数据                             |
| yG               | 复制游标所在行到最后一行的所有数据                           |
| y0               | 复制光标所在的那个字符到该行行首的所有数据                   |
| y$               | 复制光标所在的那个字符到该行行尾的所有数据                   |
| p, P             | p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用) |
| J                | 将光标所在行与下一行的数据结合成同一行                       |
| c                | 重复删除多个数据，例如向下删除 10 行，[ 10cj ]               |
| u                | 复原前一个动作。(常用)                                       |
| [Ctrl]+r         | 重做上一个动作。(常用)                                       |

**第二部分：一般模式切换到编辑模式的可用的按钮说明**

| 进入输入或取代的编辑模式 |                                                              |
| :----------------------- | ------------------------------------------------------------ |
| i, I                     | 进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用) |
| a, A                     | 进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) |
| o, O                     | 进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用) |
| r, R                     | 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) |
| [Esc]                    | 退出编辑模式，回到一般模式中(常用)                           |

**第三部分：一般模式切换到指令行模式的可用的按钮说明**

| 指令行的储存、离开等指令                                     |                                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| :w                                                           | 将编辑的数据写入硬盘档案中(常用)                             |
| :w!                                                          | 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ |
| :q                                                           | 离开 vi (常用)                                               |
| :q!                                                          | 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。    |
| 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ |                                                              |
| :wq                                                          | 储存后离开，若为 :wq! 则为强制储存后离开 (常用)              |
| ZZ                                                           | 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！ |
| :w [filename]                                                | 将编辑的数据储存成另一个档案（类似另存新档）                 |
| :r [filename]                                                | 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 |
| :n1,n2 w [filename]                                          | 将 n1 到 n2 的内容储存成 filename 这个档案。                 |
| :! command                                                   | 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！ |
| :set nu                                                      | 显示行号，设定之后，会在每一行的前缀显示该行的行号           |
| :set nonu                                                    | 与 set nu 相反，为取消行号！                                 |

# 5.文本处理

## 5.1 查看和合并文件（cat）

cat，concatenate（连接、连续）的简写。其基本格式如下：

```
# cat [选项] 文件名
或者
# cat 文件1 文件2 > 文件3
```

前者用于显示文件的内容，后者用于连接合并文件。

| 选项 | 含义                                                     |
| ---- | -------------------------------------------------------- |
| -A   | 相当于 -vET 选项的整合，用于列出所有隐藏符号；           |
| -E   | 列出每行结尾的回车符 $；                                 |
| -n   | 对输出的所有行进行编号；                                 |
| -b   | 同 -n 不同，此选项表示只对非空行进行编号。               |
| -T   | 把 Tab 键 ^I 显示出来；                                  |
| -V   | 列出特殊字符；                                           |
| -s   | 当遇到有连续 2 行以上的空白行时，就替换为 1 行的空白行。 |

注意，cat 命令用于查看文件内容时，不论文件内容有多少，都会一次性显示。如果文件非常大，那么文件开头的内容就看不到了。不过 Linux 可以使用`PgUp+上箭头`组合键向上翻页，但是这种翻页是有极限的

## 5.2 查看文件内容（more/less）

对于大数据量的文件，可以使用more/less命令分页显示文件内容，区别在于，使用 more 命令浏览文件内容时，只能不断向后翻看，而使用 less 命令浏览，既可以向后翻看，也可以向前翻看。

- more

  ```
  more [选项] 文件名
  ```

  more 命令比较简单，一般不用什么选项，对于下列的选项，只需有影响即可。

  | 选项 | 含义                                                     |
  | ---- | -------------------------------------------------------- |
  | -f   | 计算行数时，以实际的行数，而不是自动换行过后的行数。     |
  | -p   | 不以卷动的方式显示每一页，而是先清除屏幕后再显示内容。   |
  | -c   | 跟 -p 选项相似，不同的是先显示内容再清除其他旧资料。     |
  | -s   | 当遇到有连续两行以上的空白行时，就替换为一行的空白行。   |
  | -u   | 不显示下引号（根据环境变量 TERM 指定的终端而有所不同）。 |
  | +n   | 从第 n 行开始显示文件内容，n 代表数字。                  |
  | -n   | 一次显示的行数，n 代表数字。                             |

  more 命令的执行会打开一个交互界面，因此读者有必要了解一些交互命令，常用的交互命令如下所示。

  | 交互指令            | 功能                         |
  | ------------------- | ---------------------------- |
  | h 或 ？             | 显示 more 命令交互命令帮助。 |
  | q 或 Q              | 退出 more。                  |
  | v                   | 在当前行启动一个编辑器。     |
  | :f                  | 显示当前文件的文件名和行号。 |
  | !<命令> 或 :!<命令> | 在子Shell中执行指定命令。    |
  | 回车键              | 向下移动一行。               |
  | 空格键              | 向下移动一页。               |
  | Ctrl+l              | 刷新屏幕。                   |
  | =                   | 显示当前行的行号。           |
  | '                   | 转到上一次搜索开始的地方。   |
  | Ctrf+f              | 向下滚动一页。               |
  | .                   | 重复上次输入的命令。         |
  | / 字符串            | 搜索指定的字符串。           |
  | d                   | 向下移动半页。               |
  | b                   | 向上移动一页。               |

- less

  ```
  # less [选项] 文件名
  ```

  此命令可用的选项以及各自的含义如下所示。

  | 选项            | 选项含义                                               |
  | --------------- | ------------------------------------------------------ |
  | -N              | 显示每行的行号。                                       |
  | -S              | 行过长时将超出部分舍弃。                               |
  | -e              | 当文件显示结束后，自动离开。                           |
  | -g              | 只标志最后搜索到的关键同。                             |
  | -Q              | 不使用警告音。                                         |
  | -i              | 忽略搜索时的大小写。                                   |
  | -m              | 显示类似 more 命令的百分比。                           |
  | -f              | 强迫打开特殊文件，比如外围设备代号、目录和二进制文件。 |
  | -s              | 显示连续空行为一行。                                   |
  | -b <缓冲区大小> | 设置缓冲区的大小。                                     |
  | -o <文件名>     | 将 less 输出的内容保存到指定文件中。                   |
  | -x <数字>       | 将【Tab】键显示为规定的数字空格。                      |


  在使用 less 命令查看文件内容的过程中，和 more 命令一样，也会进入交互界面，因此需要掌握一些常用的交互指令，如下 所示：

| 交互指令   | 功能                                   |
| ---------- | -------------------------------------- |
| /字符串    | 向下搜索“字符串”的功能。               |
| ?字符串    | 向上搜索“字符串”的功能。               |
| n          | 重复*前一个搜索（与 / 成 ? 有关）。    |
| N          | 反向重复前一个搜索（与 / 或 ? 有关）。 |
| b          | 向上移动一页。                         |
| d          | 向下移动半页。                         |
| h 或 H     | 显示帮助界面。                         |
| q 或 Q     | 退出 less 命令。                       |
| y          | 向上移动一行。                         |
| 空格键     | 向下移动一页。                         |
| 回车键     | 向下移动一行。                         |
| 【PgDn】键 | 向下移动一页。                         |
| 【PgUp】键 | 向上移动一页。                         |
| Ctrl+f     | 向下移动一页。                         |
| Ctrl+b     | 向上移动一页。                         |
| Ctrl+d     | 向下移动一页。                         |
| Ctrl+u     | 向上移动半页。                         |
| j          | 向下移动一行。                         |
| k          | 向上移动一行。                         |
| G          | 移动至最后一行。                       |
| g          | 移动到第一行。                         |
| ZZ         | 退出 less 命令。                       |
| v          | 使用配置的编辑器编辑当前文件。         |
| [          | 移动到本文档的上一个节点。             |
| ]          | 移动到本文档的下一个节点。             |
| p          | 移动到同级的上一个节点。               |
| u          | 向上移动半页。                         |



## 5.3 显示文件开头/结尾内容（head/tail）

head/tail可以分别显示文件前/后若干行的文件内容。

- head

  ```
  # head [选项] 文件名
  ```

  | 选项 | 含义                                                         |
  | ---- | ------------------------------------------------------------ |
  | -n K | 这里的 K 表示行数，该选项用来显示文件前 K 行的内容；如果使用 "-K" 作为参数，则表示除了文件最后 K 行外，显示剩余的全部内容。 |
  | -c K | 这里的 K 表示字节数，该选项用来显示文件前 K 个字节的内容；如果使用 "-K"，则表示除了文件最后 K 字节的内容，显示剩余全部内容。 |
  | -v   | 显示文件名；                                                 |

- tail

  ```
  # tail [选项] 文件名
  ```

  | 选项 | 含义                                                         |
  | ---- | ------------------------------------------------------------ |
  | -n K | 这里的 K 指的是行数，该选项表示输出最后 K 行，在此基础上，如果使用 -n +K，则表示从文件的第 K 行开始输出。 |
  | -c K | 这里的 K 指的是字节数，该选项表示输出文件最后 K 个字节的内容，在此基础上，使用 -c +K 则表示从文件第 K 个字节开始输出。 |
  | -f   | 输出文件变化后新增加的数据。                                 |

# 6.磁盘管理

Linux磁盘管理常用命令为 df、du。

- df ：列出文件系统的整体磁盘使用量
- du：检查磁盘空间使用量

## 6.1 查看文件系统硬盘使用情况 (df)

检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。

语法：

```
df [-ahikHTm] [目录或文件名]
```

| 选项 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | 列出所有的文件系统，包括系统特有的 /proc 等文件系统；        |
| -k   | 以 KBytes 的容量显示各文件系统；                             |
| -m   | 以 MBytes 的容量显示各文件系统；                             |
| -h   | 以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；     |
| -H   | 以 M=1000K 取代 M=1024K 的进位方式；                         |
| -T   | 显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出； |
| -i   | 不用硬盘容量，而以 inode 的数量来显示                        |

测试：

```
# df
Filesystem      1K-blocks      Used Available Use% Mounted on
/dev/hdc2         9920624   3823112   5585444  41% /
/dev/hdc3         4956316    141376   4559108   4% /home
/dev/hdc1          101086     11126     84741  12% /boot
tmpfs              371332         0    371332   0% /dev/shm
```

## 6.2 统计目录或文件所占磁盘空间大小(du)

  df命令是从文件系统的角度考虑的，通过文件系统中未分配的空间来确定文件系统中已经分配的空间大小。也就是说，在使用 df 命令统计分区时，不仅要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除，但是程序并没有释放空间）。

与df命令不同，而 du 命令是面向文件的，只会计算文件或目录占用的磁盘空间。也就是说，df 命令统计的分区更准确，是真正的空闲空间。  

语法：

```
du [-ahskm] 文件或目录名称
```

| 选项 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | 列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 |
| -h   | 以人们较易读的容量格式 (G/M) 显示；                          |
| -s   | 列出总量而已，而不列出每个各别的目录占用容量；               |
| -S   | 不包括子目录下的总计，与 -s 有点差别。                       |
| -k   | 以 KBytes 列出容量显示；                                     |
| -m   | 以 MBytes 列出容量显示；                                     |

测试：

```
# du
8       ./test4     <==每个目录都会列出来
8       ./test2
....中间省略....
12      ./.gconfd   <==包括隐藏文件的目录
220     .           <==这个目录(.)所占用的总量
```

## 6.3 磁盘挂载与卸除(mount)

Linux 系统中**一切皆文件**，所有文件都放置在以根目录为树根的树形目录结构中。在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构）。
		因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为**挂载**。解除此关联关系的过程称之为**卸载**。

例如，想通过命令行访问某个 U 盘中的数据

![U 盘和 Linux 系统文件目录结构](http://c.biancheng.net/uploads/allimg/190321/2-1Z321130921V9.gif)



可以看到，目前 U 盘和 Linux 系统文件分属两个文件系统，还无法使用命令行找到 U 盘文件，需要将两个文件系统进行挂载。

我们在根目录下新建一个目录 /sdb-u，通过挂载命令将 U 盘文件系统挂载到此目录。此时访问 /sdb-u/ 就等同于访问 U 盘

![文件系统挂载](http://c.biancheng.net/uploads/allimg/190321/2-1Z321130I44B.gif)





Linux 的磁盘挂载使用mount命令，卸载使用umount命令。

```
mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点
```

测试：将 /dev/hdc6 挂载到 /mnt/hdc6 上面！

```
# mount /dev/hdc6 /mnt/hdc6
```

磁盘卸载命令 umount 语法：

```
umount [-fn] 装置文件名或挂载点
```

选项与参数：

- -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；
- -n ：不升级 /etc/mtab 情况下卸除。

```
# umount /dev/hdc6
```

# 7.权限管理

## 7.1 文件属性

Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。

在Linux中我们可以使用`ll`或者`ls –l`命令来显示一个文件的属性以及文件所属的用户和组，如：

```
# ls -l
total 64
dr-xr-xr-x   2 root root 4096 Dec 14  2020 bin
dr-xr-xr-x   4 root root 4096 Apr 19  2020 boot
```

实例中，boot文件的第一个属性用"d"表示。"d"在Linux中代表该文件是一个目录文件。

在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：

- 当为[ **d** ]则是目录
- 当为[ **-** ]则是文件；
- 若是[ **l** ]则表示为链接文档 ( link file )；
- 若是[ **b** ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；
- 若是[ **c** ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。

接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。

要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。

每个文件的属性由左边第一部分的10个字符来确定（如下图）：

![](https://www.runoob.com/wp-content/uploads/2014/06/363003_1227493859FdXT.png)

从左至右用0-9这些数字来表示。

第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。

其中：

第1、4、7位表示读权限，如果用"r"字符表示，则有读权限，如果用"-"字符表示，则没有读权限；

第2、5、8位表示写权限，如果用"w"字符表示，则有写权限，如果用"-"字符表示没有写权限；

第3、6、9位表示可执行权限，如果用"x"字符表示，则有执行权限，如果用"-"字符表示，则没有执行权限。

## 7.2 修改文件权限（chmod）

chmod 命令设定文件权限的方式有 2 种，分别可以使用数字或者符号来进行权限的变更。

- 数字

  各个权限与数字的对应关系如下：

  ```
  r --> 4
  w --> 2
  x --> 1
  ```

  每种用户身份包含 3 个权限（r、w、x），通过将 3 个权限对应的数字累加，最终得到的值即可作为每种用户所具有的权限。

  基本格式为

  ```
  # chmod [-R] 权限值 文件名
  ```

  -R（注意是大写）选项表示连同子目录中的所有文件，也都修改设定的权限。

- 符号

  chmod 命令中用 **u、g、o 分别代表所有者、所属组和其他人** 3 种身份，还用 a 表示全部的身份（all 的缩写）。另外，chmod 命令仍使用 r、w、x 分别表示读、写、执行权限。

  其基本格式如图 1所示：

  ![chmod 命令基本格式](http://c.biancheng.net/uploads/allimg/190417/2-1Z41G31209649.gif)



# 8.系统管理

## 8.1 查看正在运行的进程（ps）

基本格式

```
# ps [选项]
```

选项：

- a：显示一个终端的所有进程，除会话引线外；
- u：显示进程的归属用户及内存的使用情况；
- x：显示没有控制终端的进程；
- -l：长格式显示更加详细的信息；
- -e：显示所有进程；

```
# ps aux
#查看系统中所有的进程
USER PID %CPU %MEM  VSZ  RSS   TTY STAT START TIME COMMAND
root   1  0.0  0.2 2872 1416   ?   Ss   Jun04 0:02 /sbin/init
root   2  0.0  0.0    0    0   ?    S   Jun04 0:00 [kthreadd]
```

输出信息含义如下：

| 表头    | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| USER    | 该进程是由哪个用户产生的。                                   |
| PID     | 进程的 ID。                                                  |
| %CPU    | 该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。 |
| %MEM    | 该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。 |
| VSZ     | 该进程占用虚拟内存的大小，单位为 KB。                        |
| RSS     | 该进程占用实际物理内存的大小，单位为 KB。                    |
| TTY     | 该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。 |
| STAT    | 进程状态。常见的状态有以下几种：-D：不可被唤醒的睡眠状态，通常用于 I/O 情况。-R：该进程正在运行。-S：该进程处于睡眠状态，可被唤醒。-T：停止状态，可能是在后台暂停或进程处于除错状态。-W：内存交互状态（从 2.6 内核开始无效）。-X：死掉的进程（应该不会出现）。-Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。-<：高优先级（以下状态在 BSD 格式中出现）。-N：低优先级。-L：被锁入内存。-s：包含子进程。-l：多线程（小写 L）。-+：位于后台。 |
| START   | 该进程的启动时间。                                           |
| TIME    | 该进程占用 CPU 的运算时间，注意不是系统时间。                |
| COMMAND | 产生此进程的命令名。                                         |

## 8.2 持续监听进程运行状态(top)

top 命令的基本格式如下：

```
#top [选项]
```

选项：

- -d 秒数：指定 top 命令每隔几秒更新。默认是 3 秒；
- -b：使用批处理模式输出。一般和"-n"选项合用，用于把 top 命令重定向到文件中；
- -n 次数：指定 top 命令执行的次数。一般和"-"选项合用；
- -p 进程PID：仅查看指定 ID 的进程；
- -s：使 top 命令在安全模式中运行，避免在交互模式中出现错误；
- -u 用户名：只监听某个用户的进程；


在 top 命令的显示窗口中，还可以使用如下按键，进行一下交互操作：

- ? 或 h：显示交互模式的帮助；
- P：按照 CPU 的使用率排序，默认就是此选项；
- M：按照内存的使用率排序；
- N：按照 PID 排序；
- T：按照 CPU 的累积运算时间排序，也就是按照 TIME+ 项排序；
- k：按照 PID 给予某个进程一个信号。一般用于中止某个进程，信号 9 是强制中止的信号；
- r：按照 PID 给某个进程重设优先级（Nice）值；
- q：退出 top 命令；

我们看看 top 命令的执行结果，如下：

```
[root@localhost ~]# top
top - 12:26:46 up 1 day, 13:32, 2 users, load average: 0.00, 0.00, 0.00
Tasks: 95 total, 1 running, 94 sleeping, 0 stopped, 0 zombie
Cpu(s): 0.1%us, 0.1%sy, 0.0%ni, 99.7%id, 0.1%wa, 0.0%hi, 0.1%si, 0.0%st
Mem: 625344k total, 571504k used, 53840k free, 65800k buffers
Swap: 524280k total, 0k used, 524280k free, 409280k cached
PID   USER PR NI VIRT  RES  SHR S %CPU %MEM   TIME+ COMMAND
19002 root 20  0 2656 1068  856 R  0.3  0.2 0:01.87 top
1     root 20  0 2872 1416 1200 S  0.0  0.2 0:02.55 init
2     root 20  0    0    0    0 S  0.0  0.0 0:00.03 kthreadd
3     root RT  0    0    0    0 S  0.0  0.0 0:00.00 migration/0
4     root 20  0    0    0    0 S  0.0  0.0 0:00.15 ksoftirqd/0
5     root RT  0    0    0    0 S  0.0  0.0 0:00.00 migration/0
6     root RT  0    0    0    0 S  0.0  0.0 0:10.01 watchdog/0
7     root 20  0    0    0    0 S  0.0  0.0 0:05.01 events/0
8     root 20  0    0    0    0 S  0.0  0.0 0:00.00 cgroup
9     root 20  0    0    0    0 S  0.0  0.0 0:00.00 khelper
10    root 20  0    0    0    0 S  0.0  0.0 0:00.00 netns
11    root 20  0    0    0    0 S  0.0  0.0 0:00.00 async/mgr
12    root 20  0    0    0    0 S  0.0  0.0 0:00.00 pm
13    root 20  0    0    0    0 S  0.0  0.0 0:01.70 sync_supers
14    root 20  0    0    0    0 S  0.0  0.0 0:00.63 bdi-default
15    root 20  0    0    0    0 S  0.0  0.0 0:00.00 kintegrityd/0
16    root 20  0    0    0    0 S  0.0  0.0 0:02.52 kblockd/0
17    root 20  0    0    0    0 S  0.0  0.0 0:00.00 kacpid
18    root 20  0    0    0    0 S  0.0  0.0 0:00.00 kacpi_notify
```

我们解释一下命令的输出。top 命令的输出内容是动态的，默认每隔 3 秒刷新一次。命令的输出主要分为两部分：

1. 第一部分是前五行，显示的是整个系统的资源使用状况，我们就是通过这些输出来判断服务器的资源使用状态的；
2. 第二部分从第六行开始，显示的是系统中进程的信息；

我们先来说明第一部分的作用。

- 第一行为任务队列信息

  | 内 容                         | 说 明                                                        |
  | ----------------------------- | ------------------------------------------------------------ |
  | 12:26:46                      | 系统当前时间                                                 |
  | up 1 day, 13:32               | 系统的运行时间.本机己经运行 1 天 13 小时 32 分钟             |
  | 2 users                       | 当前登录了两个用户                                           |
  | load average: 0.00,0.00，0.00 | 系统在之前 1 分钟、5 分钟、15 分钟的平均负载。如果 CPU 是单核的，则这个数值超过 1 就是高负载：如果 CPU 是四核的，则这个数值超过 4 就是高负载 （这个平均负载完全是依据个人经验来进行判断的，一般认为不应该超过服务器 CPU 的核数） |

- 第二行为进程信息

  | 内 容           | 说 明                                          |
  | --------------- | ---------------------------------------------- |
  | Tasks: 95 total | 系统中的进程总数                               |
  | 1 running       | 正在运行的进程数                               |
  | 94 sleeping     | 睡眠的进程数                                   |
  | 0 stopped       | 正在停止的进程数                               |
  | 0 zombie        | 僵尸进程数。如果不是 0，则需要手工检查僵尸进程 |

- 第三行为 CPU 信息

  | 内 容           | 说 明                                                        |
  | --------------- | ------------------------------------------------------------ |
  | Cpu(s): 0.1 %us | 用户模式占用的 CPU 百分比                                    |
  | 0.1%sy          | 系统模式占用的 CPU 百分比                                    |
  | 0.0%ni          | 改变过优先级的用户进程占用的 CPU 百分比                      |
  | 99.7%id         | 空闲 CPU 占用的 CPU 百分比                                   |
  | 0.1%wa          | 等待输入/输出的进程占用的 CPU 百分比                         |
  | 0.0%hi          | 硬中断请求服务占用的 CPU 百分比                              |
  | 0.1%si          | 软中断请求服务占用的 CPU 百分比                              |
  | 0.0%st          | st（steal time）意为虚拟时间百分比，就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比 |

- 第四行为物理内存信息

  | 内 容              | 说 明                                                        |
  | ------------------ | ------------------------------------------------------------ |
  | Mem: 625344k total | 物理内存的总量，单位为KB                                     |
  | 571504k used       | 己经使用的物理内存数量                                       |
  | 53840k&ee          | 空闲的物理内存数量。我们使用的是虚拟机，共分配了 628MB内存，所以只有53MB的空闲内存 |
  | 65800k buffers     | 作为缓冲的内存数量                                           |

- 第五行为交换分区（swap）信息

  | 内 容               | 说 明                        |
  | ------------------- | ---------------------------- |
  | Swap: 524280k total | 交换分区（虚拟内存）的总大小 |
  | Ok used             | 已经使用的交换分区的大小     |
  | 524280k free        | 空闲交换分区的大小           |
  | 409280k cached      | 作为缓存的交换分区的大小     |

  我们通过 top 命令的第一部分就可以判断服务器的健康状态。如果 1 分钟、5 分钟、15 分钟的平均负载高于 1，则证明系统压力较大。如果 CPU 的使用率过高或空闲率过低，则证明系统压力较大。如果物理内存的空闲内存过小，则也证明系统压力较大。

这时，我们就应该判断是什么进程占用了系统资源。如果是不必要的进程，就应该结束这些进程；如果是必需进程，那么我们该増加服务器资源（比如増加虚拟机内存），或者建立集群服务器。  缓冲缓存

再来看 top 命令的第二部分输出，主要是系统进程信息，各个字段的含义如下：

- PID：进程的 ID。
- USER：该进程所属的用户。
- PR：优先级，数值越小优先级越高。
- NI：优先级，数值越小、优先级越高。
- VIRT：该进程使用的虚拟内存的大小，单位为 KB。
- RES：该进程使用的物理内存的大小，单位为 KB。
- SHR：共享内存大小，单位为 KB。
- S：进程状态。
- %CPU：该进程占用 CPU 的百分比。
- %MEM：该进程占用内存的百分比。
- TIME+：该进程共占用的 CPU 时间。
- COMMAND：进程的命令名。

## 8.3 终止进程(kill)

kill 命令会向操作系统内核发送一个信号（多是终止信号）和目标进程的 PID，然后系统内核根据收到的信号类型，对指定进程进行相应的操作。

```
# kill [信号] PID
```

常用信号如下

| 信号编号 | 信号名 | 含义                                                         |
| -------- | ------ | ------------------------------------------------------------ |
| 0        | EXIT   | 程序退出时收到该信息。                                       |
| 1        | HUP    | 挂掉电话线或终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化。 |
| 2        | INT    | 表示结束进程，但并不是强制性的，常用的 "Ctrl+C" 组合键发出就是一个 kill -2 的信号。 |
| 3        | QUIT   | 退出。                                                       |
| 9        | KILL   | 杀死进程，即强制结束进程。                                   |
| 11       | SEGV   | 段错误。                                                     |
| 15       | TERM   | 正常结束进程，是 kill 命令的默认信号。                       |

## 8.4 监控系统资源(vmstat)

vmstat命令，是 Virtual Meomory Statistics（虚拟内存统计）的缩写，可用来监控 CPU 使用、进程状态、内存使用、虚拟内存使用、硬盘输入/输出状态等信息

此命令的基本格式有如下 2 种：

```
# vmstat [-a] [刷新延时 刷新次数]
# vmstat [选项]
```

第二章方式选项说明如下：

| 选项              | 含义                                                         |
| ----------------- | ------------------------------------------------------------ |
| -fs               | -f：显示从启动到目前为止，系统复制（fork）的程序数，此信息是从 /proc/stat 中的 processes 字段中取得的。 -s：将从启动到目前为止，由一些事件导致的内存变化情况列表说明。 |
| -S 单位           | 令输出的数据显示单位，例如用 K/M 取代 bytes 的容量。         |
| -d                | 列出硬盘有关读写总量的统计表。                               |
| -p 分区设备文件名 | 查看硬盘分区的读写情况。                                     |

例如：

```
# vmstat 1 3
#使用vmstat检测，每隔1秒刷新一次，共刷新3次
procs ——memory—— swap —io system ——cpu——
r b swpd free buff cache si so bi bo in cs us sy id wa st
r b swpd free buff cache si so bi bo in cs us sy id wa st
0 0 0 407376 55772 84644 0 0 5 2 9 10 0 0 100 0 0
0 0 0 407368 55772 84644 0 0 0 0 12 10 0 0 100 0 0
0 0 0 407368 55772 84644 0 0 0 0 15 13 0 0 100 0 0
```

输出信息中，各个字段以及含义如下：

| 字段   | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| procs  | 进程信息字段：-r：等待运行的进程数，数量越大，系统越繁忙。-b：不可被唤醒的进程数量，数量越大，系统越繁忙。 |
| memory | 内存信息字段：-swpd：虚拟内存的使用情况，单位为 KB。-free：空闲的内存容量，单位为 KB。-buff：缓冲的内存容量，单位为 KB。-cache：缓存的内存容量，单位为 KB。 |
| swap   | 交换分区信息字段：-si：从磁盘中交换到内存中数据的数量，单位为 KB。-so：从内存中交换到磁盘中数据的数量，单位为 KB。这两个数越大，表明数据需要经常在磁盘和内存之间进行交换，系统性能越差。 |
| io     | 磁盘读/写信息字段：-bi：从块设备中读入的数据的总量，单位是块。-bo：写到块设备的数据的总量，单位是块。这两个数越大，代表系统的 I/O 越繁忙。 |
| system | 系统信息字段：-in：每秒被中断的进程次数。-cs：每秒进行的事件切换次数。这两个数越大，代表系统与接口设备的通信越繁忙。 |
| cpu    | CPU信息字段：-us：非内核进程消耗 CPU 运算时间的百分比。-sy：内核进程消耗 CPU 运算时间的百分比。-id：空闲 CPU 的百分比。-wa：等待 I/O 所消耗的 CPU 百分比。-st：被虚拟机所盗用的 CPU 百分比。 |

## 8.5 查看内存使用状态（free）

基本格式如下：

```
# free [选项]
```

| 选项        | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| -b          | 以 Byte（字节）为单位，显示内存使用情况。                    |
| -k          | 以 KB 为单位，显示内存使用情况，此选项是 free 命令的默认选项。 |
| -m          | 以 MB 为单位，显示内存使用情况。                             |
| -g          | 以 GB 为单位，显示内存使用情况。                             |
| -t          | 在输出的最终结果中，输出内存和 swap 分区的总量。             |
| -o          | 不显示系统缓冲区这一列。                                     |
| -s 间隔秒数 | 根据指定的间隔时间，持续显示内存使用情况。                   |

例如：

```
[root@localhost ~]# free -m
                  total       used    free   shared   buffers    cached
Mem:           725        666      59           0       132         287
-/+ buffers/cache:     245     479
Swap:           996            0     996
```

第一行显示的是各个列的列表头信息，各自的含义如下所示：

- total 是总内存数；
- used 是已经使用的内存数；
- free 是空闲的内存数；
- shared 是多个进程共享的内存总数；
- buffers 是缓冲内存数；
- cached 是缓存内存数。

# 9. 查找

## 9.1 查找文件(find)

`find` 命令应该是最经典的命令了，格式如下

```
find   path  -option  [-print]   [ -exec   -ok   |xargs  |grep] [command  {} \;  ]
```

- path：要查找的目录路径。 

  - -~ 表示$HOME目录

  - **.** 表示当前目录
  - / 表示根目录 

- print：表示将结果输出到标准输出。 

- exec：对匹配的文件执行该参数所给出的shell命令。 
        形式为command {} \;，注意{}与\;之间有空格 

- ok：与exec作用相同，
        区别在于，在执行命令之前，都会给出提示，让用户确认是否执行 

- |xargs  与exec作用相同 ，起承接作用。区别在于 **|xargs** 主要用于承接删除操作 ，而 **-exec** 都可用 如复制、移动、重命名等

- options：表示查找方式，常用选项如下

| 选项              | 含义                                               |
| ----------------- | -------------------------------------------------- |
| -name   filename  | 查找名为filename的文件                             |
| -perm             | 按执行权限来查找                                   |
| -user    username | 按文件属主来查找                                   |
| -group groupname  | 按组来查找                                         |
| -mtime   -n +n    | 按文件更改时间来查找文件，-n指n天以内，+n指n天以前 |
| -atime    -n +n   | 按文件访问时间来查找文件，-n指n天以内，+n指n天以前 |
| -ctime    -n +n   | 按文件创建时间来查找文件，-n指n天以内，+n指n天以前 |
| -size      n[c]   | 查长度为n块[或n字节]的文件                         |

## 9.2 按文件名搜索文件(locate)

`locate` 是另外一个根据文件名来搜索文件的命令。区别于 find 命令，locate 命令无需指定路径，直接搜索即可。

这个命令不是直接去系统的各个角落搜索文件，而是在一个叫 `mlocate.db` 的数据库下搜索。这个数据库位于 `/var/lib/mlocate/mlocate.db` ，它包含了系统里所有文件的索引，并且会在每天早上的时候由 cron 工具自动更新一次。

正因为如此，locate 的搜索速度远快于 find 命令，因为它直接在数据库里检索，速度自然更快。

但是 locate 命令有个弊端，它无法搜索当天所创建的文件，因为它的数据库一天只在早上更新一次。

为了解决这个问题，我们可以使用 `updatedb` 命令手动去更新它的数据库：

```
$ sudo updadb
```

基本格式如下

```
 # locate [选项] 文件名
```

| 选项 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| -i   | 忽略大小写；                                                 |
| -c   | 不输出文件名，仅计算找到的文件数量；                         |
| -l   | 仅输出几行的意思，例如输出5行则是-l 5；                      |
| -S   | 输出locate所使用的数据库文件的相关信息，包括该数据库记录的文件/目录数量等； |
| -r   | 后面可接正则表达式的显示方式                                 |

## 9.3 查找Linux命令的位置(which)

`which` 命令主要用来查找可执行文件的位置，它搜索的位置指定在 `$PATH` 及 `$MANPATH` 环境变量下的值，默认情况下，`which` 命令将显示可执行文件的第一个存储位置。

格式如下：

```
which [选项] 可执行文件名称
```

| 选项           | 含义                                                         |
| -------------- | ------------------------------------------------------------ |
| -n<文件名长度> | 定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 |
| -p<文件名长度> | 与-n参数相同，但此处的包括了文件的路径。                     |
| -V             | 显示版本信息                                                 |

## 9.4 査找二进制命令、源文件和说明文件(whereis)

whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）

基本格式：

```
whereis [选项] {文件名}
```

| 选项 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| -b   | 定位可执行文件。                                             |
| -m   | 定位帮助文件。                                               |
| -s   | 定位源代码文件。                                             |
| -u   | 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。 |
| -B   | 指定搜索可执行文件的路径。                                   |
| -M   | 指定搜索帮助文件的路径。                                     |
| -S   | 指定搜索源代码文件的路径。                                   |