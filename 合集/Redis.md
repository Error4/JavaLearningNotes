Redis

# 1.redis演变过程

## 单机

持久化，做数据备份，单机下Redis读的速度是110000次/s,写的速度是81000次/s 。

## 主从复制

复制是Redis高可用的基础，实现了读操作的负载均衡和简单的故障恢复

## 哨兵

在复制的基础上，哨兵实现了自动化的故障恢复，缺陷是写操作无法负载均衡，存储能力也收到单机版的限制

## 集群  

较为完善的解决方案

# 2.集群

- redis集群是没有统一的入口的，客户端（client）连接集群的时候连接集群中的任意节点（node）即可，集群内部的节点是相互通信的（PING-PONG机制），每个节点都是一个redis实例；
- 为了实现集群的高可用，即判断节点是否健康（能否正常使用），redis-cluster有这么一个投票容错机制：**如果集群中超过半数的master节点投票认为某个节点挂了（`master`节点与`master`节点通信超时(`cluster-node-timeout`)），那么这个节点就挂了（fail）**。这是判断节点是否挂了的方法；
- 那么如何判断集群是否挂了呢? -> 如果集群中任意一个节点挂了，而且该节点没有从节点（备份节点），那么这个集群就挂了。这是判断集群是否挂了的方法；
- 那么为什么任意一个节点挂了（没有从节点）这个集群就挂了呢？ -> 因为集群内置了**16384**个slot（哈希槽），并且把所有的物理节点映射到了这16384[0-16383]个slot上，或者说把这些slot均等的分配给了各个节点。当需要在Redis集群存放一个数据（key-value）时，**对于存储的每个key值 使用CRC16(KEY)&16384=slot ，得到他对应的hash slot ，并在访问key时就去找他的hash slot在哪一个节点上 ，然后由当前访问节点从实际被分配了这个hash slot的节点去取数据**。所以一旦某个节点挂了，该节点对应的slot就无法使用，那么就会导致集群无法正常工作。

**搭建环境准备**

- Redis集群至少需要3个节点，因为投票容错机制要求超过半数节点认为某个节点挂了该节点才是挂了，所以2个节点无法构成集群。

- */要保证集群的高可用，需要每个节点都有从节点，也就是备份节点，所以Redis集群至少需要6台服务器。因为我没有那么多服务器，也启动不了那么多虚拟机，所在这里搭建的是伪分布式集群，即一台服务器虚拟运行6个redis实例，修改端口号为（7001-7006），当然实际生产环境的Redis集群搭建和这里是一样的。
- 使用官方的redis-trib.rb搭建集群，需要安装ruby，自动将哈希槽均匀的分配到节点上

**创建集群**

注意：配置文件更改：将`cluster-enabled yes` 的注释打开

# 3.补充

## 3.1 FORK

Redis在进行RDB的快照生成有两种方法，一种是save，一种是bgsave。由于Redis是单进程单线程，**如果直接使用save的话，会进行一个庞大的文件IO操作阻塞线上的业务，因此一般不会直接采用save而是采用bgsave。在使用basave的时候，Redis会fork一个子进程，快照的持久化就交给这个子进程去处理**，而父进程继续处理线上业务的请求。

fork机制是linux操作系统的一个进程机制，当父进程fork出来一个子进程，子进程和父进程拥有共同的内存数据结构，子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段。

一开始两个进程都具备了相同的内存段，**子进程在做数据持久化的时候，不会去修改现在的内存数据，而是会采用COW（Copy on Write）的方式将数据段页面进行分离。**当父进程修改了某一个数据段时，被共享的页面就会复制一份分离出来，然后父进程再在新的数据端进行修改。这个过程也称为分裂的过程，**本来父子进程都指向很多相同的内存块，但是如果父进程对其中某个内存块进行修改，就会将其复制出来，进行分裂再在新的内存块上进行修改。因为子进程在fork的时候就可以固定内存，这个时间点的数据将不会产生变化。**所以我们可以安心地产生快照而不用担心快照的内容受到父进程业务请求的影响。

## 3.2 集群脑裂

简单的方案，Redis 2.8版本开始，配置文件中配置即可

```
// master 至少有 3 个副本连接
min-slaves-to-write 3
// 数据复制和同步的延迟不能超过 10 秒
min-slaves-max-lag 10
```

**第一个参数表示连接到master的最少slave数量**
**第二个参数表示slave连接到master的最大延迟时间**

配置了这两个参数之后，如果发生集群脑裂，原先的master节点接收到客户端的写入请求会拒绝，就可以减少数据同步之后的数据丢失。

## 3.3 主从复制过程

从节点执行 slaveof 命令

从节点只是保存了 slaveof 命令中主节点的信息，并没有立即发起复制

从节点内部的定时任务发现有主节点的信息，开始使用 socket 连接主节点

连接建立成功后，发送 ping 命令，希望得到 pong 命令响应，否则会进行重连

如果主节点设置了权限，那么就需要进行权限验证；如果验证失败，复制终止。

权限验证通过后，进行数据同步，**这是耗时最长的操作**，主节点将把所有的数据全部发送给从节点。

当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来，**主节点就会持续的把写命令发送给从节点，保证主从数据一致性**。

### 数据同步

**redis 同步有 2 个命令：**

sync 和 **psync**，前者是 redis 2.8 之前的同步命令，后者是 redis 2.8 为了优化 sync 新设计的命令

**psync 命令需要 3 个组件支持：**

- 主从节点各自复制偏移量

  主节点和从节点分别维护一个复制偏移量（offset），代表的是**主节点向从节点传递的字节数**；

  主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。

  **offset用于判断主从节点的数据库状态是否一致**，如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据

  而缺省的那部分数据存储的位置，就是下面说的缓冲区

- 主节点复制积压缓冲区

  复制积压缓冲区是一个保存在主节点的一个固定长度的先进先出的队列。默认大小 1MB。

  在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给**复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。**

- 主节点运行 ID

  每个 redis 启动的时候，都会生成一个 40 位的运行 ID，runid。

  运行 ID 的主要作用是用来识别 Redis 节点

  主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制：

#### 全量复制

用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。

#### 部分复制

用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点

## 3.4.跳表

跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。Redis的sortedset就是基于跳表的实现

![跳表](D:\Program Files\笔记\image\跳表.JPG)

与红黑树等平衡树相比，跳跃表具有以下优点：
插入速度非常快速，因为不需要进行旋转等操作来维护平衡性； 更容易实现； 支持无锁操作。

## 3.5 redis与Memcached

### 数据类型 

Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。 

### 数据持久化 

Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。

###  分布式

Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要 先在客户端计算一次数据所在的节点。
Redis Cluster 实现了分布式的支持。

## 3.6 额外的数据类型

- bitmap

  BitMap 就是通过一个 bit 位来表示某个元素对应的值或者状态, 其中的 key 就是对应元素本身，实际上底层也是通过对字符串的操作来实现

- hyperloglog

  用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。

  在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数

  **比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。**

- Geo

  可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作

